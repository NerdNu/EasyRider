package nu.nerd.easyrider.db;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.OfflinePlayer;
import org.bukkit.Sound;
import org.bukkit.SoundCategory;
import org.bukkit.attribute.Attribute;
import org.bukkit.attribute.AttributeInstance;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.entity.AbstractHorse;
import org.bukkit.entity.AnimalTamer;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;

import nu.nerd.easyrider.EasyRider;
import nu.nerd.easyrider.HorseEquipment;
import nu.nerd.easyrider.PlayerState;
import nu.nerd.easyrider.RateLimiter;
import nu.nerd.easyrider.Util;

// ----------------------------------------------------------------------------
/**
 * Holds the persistent state of a horse.
 *
 * The names of transient fields begin with an underscore; persistent fields do
 * not, since it simplifies mapping to database columns when an ORM is used.
 *
 * hashCode() and equals() methods have been generated by the Eclipse IDE.
 */
public class SavedHorse implements Cloneable {
    // --------------------------------------------------------------------------
    /**
     * Default constructor.
     */
    public SavedHorse() {
    }

    // ------------------------------------------------------------------------
    /**
     * Constructor.
     *
     * @param abstractHorse the AbstractHorse entity.
     */
    public SavedHorse(AbstractHorse abstractHorse) {
        setNew();
        setUuid(abstractHorse.getUniqueId());
        speedLevel = jumpLevel = healthLevel = (Util.isTrainable(abstractHorse) ? 1 : 0);
        setHydration(0.5);
        setLastAccessed(System.currentTimeMillis());
        observe(abstractHorse);
        observeInventory(abstractHorse);
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if the AbstractHorse entity is trainable.
     *
     * Untrainable AbstractHorses are distinguished by setting the speed, health
     * and jump levels to 0.
     *
     * @return true if the AbstractHorse entity is trainable.
     */
    public boolean isTrainable() {
        return speedLevel > 0;
    }

    // ------------------------------------------------------------------------
    /**
     * @see Object#clone()
     *
     *      SavedHorse is a POD type, so cloning is trivial. The Location is
     *      assumed to not be mutated, and to be a new clone of the Entity's
     *      Location whenever it is set.
     *
     * @throws CloneNotSupportedException
     */
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    // ------------------------------------------------------------------------
    /**
     * Swap the training stats and AbstractHorse attributes of this SavedHorse
     * with the specified other SavedHorse.
     *
     * @param otherHorse the other SavedHorse.
     */
    public void swapTrainingStats(SavedHorse otherHorse) {
        int tempInt = otherHorse.getSpeedLevel();
        otherHorse.setSpeedLevel(getSpeedLevel());
        setSpeedLevel(tempInt);

        tempInt = otherHorse.getJumpLevel();
        otherHorse.setJumpLevel(getJumpLevel());
        setJumpLevel(tempInt);

        tempInt = otherHorse.getHealthLevel();
        otherHorse.setHealthLevel(getHealthLevel());
        setHealthLevel(tempInt);

        double tempDouble = otherHorse.getDistanceTravelled();
        otherHorse.setDistanceTravelled(getDistanceTravelled());
        setDistanceTravelled(tempDouble);

        tempDouble = otherHorse.getDistanceJumped();
        otherHorse.setDistanceJumped(getDistanceJumped());
        setDistanceJumped(tempDouble);

        tempInt = otherHorse.getNuggetsEaten();
        otherHorse.setNuggetsEaten(getNuggetsEaten());
        setNuggetsEaten(tempInt);
    }

    // ------------------------------------------------------------------------
    /**
     * Mark this as a new instance to be inserted into the database.
     */
    public void setNew() {
        _new = true;
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if this is a new instance to be inserted into the database.
     *
     * @return true if this is a new instance to be inserted into the database.
     */
    public boolean isNew() {
        return _new;
    }

    // ------------------------------------------------------------------------
    /**
     * Signify that this bean has unsaved changes.
     */
    public void setDirty() {
        _dirty = true;
    }

    // ------------------------------------------------------------------------
    /**
     * Signify that this bean does not have any unsaved changes.
     */
    public void setClean() {
        _dirty = _new = false;
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if this bean has unsaved changes.
     * 
     * @return true if this bean has unsaved changes.
     */
    public boolean isDirty() {
        return _dirty;
    }

    // ------------------------------------------------------------------------
    /**
     * Specify whether this horse has been marked for debug logging.
     * 
     * @param debug if true, various events concerning this horse will be
     *        logged.
     */
    public void setDebug(boolean debug) {
        _debug = debug;
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if this horse has been marked for debug logging.
     * 
     * @return true if this horse has been marked for debug logging.
     */
    public boolean isDebug() {
        return _debug;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the stored UUID of the horse.
     *
     * @param uuid the UUID.
     */
    public void setUuid(UUID uuid) {
        this.uuid = uuid;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the stored UUID of the horse.
     *
     * @return the stored UUID of the horse.
     */
    public UUID getUuid() {
        return uuid;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the UUID of the owner of this horse.
     * 
     * Also update the lastTamed timestamp to now, on change of ownership, or 0
     * if untamed.
     *
     * @param ownerUuid the owning player's UUID, or null if not owned.
     */
    public void setOwnerUuid(UUID ownerUuid) {
        // Minimise setDirty() calls.
        if (this.ownerUuid == null) {
            if (ownerUuid == null) {
                // Not tamed; owner unchanged.
                return;
            } else {
                lastTamed = System.currentTimeMillis();
            }
        } else {
            // this.ownerUuid != null
            if (this.ownerUuid.equals(ownerUuid)) {
                // Tamed; owner unchanged.
                return;
            } else {
                if (ownerUuid == null) {
                    // Untamed.
                    lastTamed = 0;
                } else {
                    // Change of ownership.
                    lastTamed = System.currentTimeMillis();
                }
            }
        }

        this.ownerUuid = ownerUuid;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the UUID of the owner of this horse, or null if not owned.
     *
     * @return the UUID of the owner of this horse, or null if not owned.
     */
    public UUID getOwnerUuid() {
        return ownerUuid;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the owner of this horse, or null if not owned.
     *
     * @param owner the owner or null.
     */
    public void setOwner(AnimalTamer owner) {
        setOwnerUuid((owner == null) ? null : owner.getUniqueId());
    }

    // ------------------------------------------------------------------------
    /**
     * Return the owner of this horse, or null if not owned.
     *
     * @return the owner of this horse, or null if not owned.
     */
    public OfflinePlayer getOwner() {
        return (ownerUuid != null) ? Bukkit.getOfflinePlayer(ownerUuid) : null;
    }

    // ------------------------------------------------------------------------
    /**
     * Reserved for future use.
     */
    public void setName(String name) {
        this.name = name;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Reserved for future use.
     */
    public String getName() {
        return name;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the displayed custom name of the horse.
     *
     * Note: This is setting what is stored in the database, not changing the
     * AbstractHorse Entity.
     *
     * @param displayName the displayed custom name of the horse.
     */
    public void setDisplayName(String displayName) {
        this.displayName = (displayName == null ? "" : displayName);
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the displayed custom name of the horse.
     *
     * @return the displayed custom name of the horse.
     */
    public String getDisplayName() {
        return displayName;
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if this horse has a custom display name.
     *
     * @return true if this horse has a custom display name.
     */
    public boolean hasDisplayName() {
        return getDisplayName() != null && getDisplayName().length() != 0;
    }

    // ------------------------------------------------------------------------
    /**
     * Return the name of this horse to use in messages.
     *
     * That will either be the horse's display name, or "This horse" or "This
     * mule", "This donkey" or "This llama".
     *
     * @return the name of this horse to use in messages.
     */
    public String getMessageName() {
        if (hasDisplayName()) {
            return getDisplayName();
        } else if (getAppearance() != null) {
            if (getAppearance().equals("mule")) {
                return "This mule";
            } else if (getAppearance().equals("donkey")) {
                return "This donkey";
            } else if (getAppearance().equals("camel")) {
                return "This camel";
            } else if (getAppearance().contains("llama")) {
                return "This llama";
            }

        }
        return "This horse";
    }

    // ------------------------------------------------------------------------
    /**
     * Set the appearance of this horse.
     *
     * @param appearance the appearance of the horse, including colour, style
     *        and variant.
     */
    public void setAppearance(String appearance) {
        this.appearance = appearance;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the appearance of the horse, including colour, style and variant.
     *
     * @return the appearance of the horse, including colour, style and variant.
     */
    public String getAppearance() {
        return appearance;
    }

    // ------------------------------------------------------------------------
    /**
     * Reserved for future use.
     */
    public void setEquipment(int equipment) {
        this.equipment = equipment;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Reserved for future use.
     */
    public int getEquipment() {
        return equipment;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the most recent location of the horse.
     *
     * @param location the location.
     */
    public void setLocation(Location location) {
        this.location = location;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the most recent location of the horse, or null if not known.
     *
     * @return the most recent location of the horse, or null if not known.
     */
    public Location getLocation() {
        return location;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the total distance travelled in metres.
     * 
     * @param distanceTravelled the distance in metres.
     */
    public void setDistanceTravelled(double distanceTravelled) {
        this.distanceTravelled = distanceTravelled;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the total distance travelled in metres.
     * 
     * @return the total distance travelled in metres.
     */
    public double getDistanceTravelled() {
        return distanceTravelled;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the total horizontal distance jumped, in metres.
     * 
     * @param distanceJumped the horizontal distance in metres.
     */
    public void setDistanceJumped(double distanceJumped) {
        this.distanceJumped = distanceJumped;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the total horizontal distance jumped, in metres.
     * 
     * @return the total horizontal distance jumped, in metres.
     */
    public double getDistanceJumped() {
        return distanceJumped;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the total amount of gold consumed, in gold nuggets.
     * 
     * @param nuggetsEaten the amount of gold, measured in nuggets.
     */
    public void setNuggetsEaten(int nuggetsEaten) {
        this.nuggetsEaten = nuggetsEaten;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the total amount of gold consumed, in gold nuggets.
     * 
     * @return the total amount of gold consumed, in gold nuggets.
     */
    public int getNuggetsEaten() {
        return nuggetsEaten;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the 1-based level that determines the horse's speed.
     * 
     * @param level the new level.
     */
    public void setSpeedLevel(int level) {
        this.speedLevel = level;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the 1-based level that determines the horse's speed.
     * 
     * @return the 1-based level that determines the horse's speed.
     */
    public int getSpeedLevel() {
        return speedLevel;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the 1-based level that determines the horse's jump strength.
     * 
     * @param level the new level.
     */
    public void setJumpLevel(int level) {
        this.jumpLevel = level;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the 1-based level that determines the horse's jump strength.
     * 
     * @return the 1-based level that determines the horse's jump strength.
     */
    public int getJumpLevel() {
        return jumpLevel;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the 1-based level that determines the horse's health.
     * 
     * @param level the new level.
     */
    public void setHealthLevel(int level) {
        this.healthLevel = level;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the 1-based level that determines the horse's health.
     * 
     * @return the 1-based level that determines the horse's health.
     */
    public int getHealthLevel() {
        return healthLevel;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the hydration of this horse from 0.0 (completely dehydrated) to 1.0
     * (fully hydrated).
     *
     * At very low hydration, the horse will not gain any ability through
     * training.
     *
     * @param hydration in the range [0.0, 1.0].
     */
    public void setHydration(double hydration) {
        this.hydration = (hydration > 1.0 ? 1.0 : (hydration < 0.0 ? 0.0 : hydration));
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the hydration level of this horse in the range 0.0 (dehydrated) to
     * 1.0 (fully hydrated).
     *
     * @return the hydration level of this horse in the range 0.0 (dehydrated)
     *         to 1.0 (fully hydrated).
     */
    public double getHydration() {
        return hydration;
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if the horse has very low hydration.
     *
     * @return true if the horse has very low hydration.
     */
    public boolean isDehydrated() {
        return (getHydration() < 0.001);
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if the horse is 99% hydrated or more.
     *
     * @return true if the horse is 99% hydrated or more.
     */
    public boolean isFullyHydrated() {
        return (getHydration() >= 0.99);
    }

    // ------------------------------------------------------------------------
    /**
     * Set the last accessed time stamp.
     *
     * @param lastAccessed a time stamp from System.currentTimeMillis().
     */
    public void setLastAccessed(long lastAccessed) {
        this.lastAccessed = lastAccessed;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the last accessed time stamp of this horse.
     *
     * @return the last accessed time stamp of this horse.
     */
    public long getLastAccessed() {
        return lastAccessed;
    }

    // ------------------------------------------------------------------------
    /**
     * Set the publicHorse boolean.
     *
     * @param publicHorse a flag allowing public access to the horse.
     */
    public void setPublicHorse(boolean publicHorse) {
        this.publicHorse = publicHorse;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the publicHorse boolean of this horse.
     *
     * @return publicHorse a flag allowing public access to the horse.
     */
    public boolean getPublicHorse() {
        return publicHorse;
    }


    // ------------------------------------------------------------------------
    /**
     * Set the last observed time stamp.
     *
     * @param lastObserved a time stamp from System.currentTimeMillis().
     */
    public void setLastObserved(long lastObserved) {
        this.lastObserved = lastObserved;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return the last observed time stamp of this horse.
     *
     * @return the last observed time stamp of this horse.
     */
    public long getLastObserved() {
        return lastObserved;
    }

    // ------------------------------------------------------------------------
    /**
     * Return the last tamed time stamp of this horse.
     *
     * @return the last tamed time stamp of this horse.
     */
    public long getLastTamed() {
        return lastTamed;
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if this horse is abandoned.
     *
     * For a horse to be abandoned, currently it must meet the following
     * conditions:
     * <ul>
     * <li>The owner has not interacted with or ridden it for a period specified
     * in the configuration (defaulting to 14 days).</li>
     * <li>It has no custom display name set.</li>
     * <li>It has no equipment: saddle, chest, armour etc.</li>
     * <li>Its quantised health and speed levels are below 2, i.e. they are both
     * 1.</li>
     * <li>It has eaten less than one golden apple or less than 9 golden carrots
     * worth of gold.</li>
     * </ul>
     *
     * @return true if this horse is abandoned.
     */
    public boolean isAbandoned() {
        long now = System.currentTimeMillis();
        return getSpeedLevel() < 2 &&
               getJumpLevel() < 2 &&
               getNuggetsEaten() < 72 &&
               !hasDisplayName() &&
               getEquipment() == 0 &&
               (now - getLastAccessed()) > EasyRider.CONFIG.ABANDONED_DAYS * 24 * 60 * 60 * 1000;
    }

    // ------------------------------------------------------------------------
    /**
     * Specify whether the corresponding AbstractHorse entity needs its
     * attibutes updated by calling {#link
     * {@link #updateAllAttributes(AbstractHorse)}.
     *
     * @param outdatedAttributes if true, the corresponding AbstractHorse entity
     *        needs all its attributes updated.
     */
    public void setOutdatedAttributes(boolean outdatedAttributes) {
        this.outdatedAttributes = outdatedAttributes;
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return true of the corresponding AbstractHorse entity needs its
     * attributes updated to match the current levels of this database horse.
     *
     * @return true of the corresponding AbstractHorse entity needs its
     *         attributes updated to match the current levels of this database
     *         horse.
     */
    public boolean hasOutdatedAttributes() {
        return outdatedAttributes;
    }

    // ------------------------------------------------------------------------
    /**
     * Update all attributes of the specified entity to match this SavedHorse.
     *
     * @param horse the AbstractHorse entity.
     */
    public void updateAllAttributes(AbstractHorse horse) {
        if (!EasyRider.CONFIG.VANILLA_STATS) {
            EasyRider.CONFIG.SPEED.updateAttribute(this, horse);
            EasyRider.CONFIG.JUMP.updateAttribute(this, horse);
            EasyRider.CONFIG.HEALTH.updateAttribute(this, horse);
        }
        setOutdatedAttributes(false);
    }

    // ------------------------------------------------------------------------
    /**
     * Return true if the specified player can access this horse.
     *
     * Only the owner and those players on the access list can do so.
     *
     * @param player the non-null player.
     * @return true if the specified player can access this horse.
     */
    public boolean canBeAccessedBy(OfflinePlayer player) {
        return player.getUniqueId().equals(getOwnerUuid()) || permittedPlayers.contains(player) || getPublicHorse();
    }

    // ------------------------------------------------------------------------
    /**
     * Retract all permission to access this horse except by the owner.
     */
    public void clearPermittedPlayers() {
        permittedPlayers.clear();
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Grant permission to access this horse to the specified players.
     *
     * @param players a collection of players, which must not include the owner.
     */
    public void addPermittedPlayers(Collection<OfflinePlayer> players) {
        permittedPlayers.addAll(players);
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Retract permission to access this horse from the specified players.
     *
     * @param players a collection of players, which must not include the owner.
     */
    public void removePermittedPlayers(Collection<OfflinePlayer> players) {
        permittedPlayers.removeAll(players);
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * Return a list of the names of players permitted to access this horse.
     *
     * @return a list of the names of players permitted to access this horse.
     */
    public List<String> getAccessList() {
        return permittedPlayers.stream().map(p -> p.getName()).collect(Collectors.toList());
    }

    // ------------------------------------------------------------------------
    /**
     * Return the contents of the inventory when it was last observed.
     * 
     * @return the contents of the inventory when it was last observed.
     */
    public ArrayList<ItemStack> getObservedInventory() {
        return observedInventory;
    }

    // ------------------------------------------------------------------------
    /**
     * Update this SavedHorse to reflect the current state of the AbstractHorse
     * Entity as it is observed in the world.
     *
     * NOTE: Call {@link HorseDB#observe(SavedHorse, AbstractHorse)} instead so
     * that the mapping of owner to owned horses is updated. That method calls
     * this one.
     *
     * Updated attributes include: last seen time, display name, appearance,
     * owner, equipment and location
     *
     * @param abstractHorse the horse entity corresponding to this SavedHorse.
     */
    public void observe(AbstractHorse abstractHorse) {
        long now = System.currentTimeMillis();
        setLastObserved(now);

        AnimalTamer newOwner = abstractHorse.getOwner();
        setOwnerUuid((newOwner != null) ? newOwner.getUniqueId() : null);
        setDisplayName(abstractHorse.getCustomName());
        setAppearance(Util.getAppearance(abstractHorse));
        setLocation(abstractHorse.getLocation());
    }

    // ------------------------------------------------------------------------
    /**
     * Update the stored record of the AbstractHorse's equipment.
     *
     * As a minor optimisation, we avoid calling this method in every
     * {@link SavedHorse#observe(AbstractHorse)} call. Strictly speaking, we
     * should only need to check the observedInventory when it is closed by a
     * player.
     * 
     * The equipment flags permit persistent custom equipment to be stored in
     * unused bits later. However, we may drop that bits in favour of custom
     * lore.
     *
     * @param abstractHorse the horse-like entity.
     */
    public void observeInventory(AbstractHorse abstractHorse) {
        int equip = (getEquipment() & ~HorseEquipment.ALL_REGULAR) | HorseEquipment.bits(abstractHorse);
        setEquipment(equip);
        observedInventory.clear();
        Inventory inv = abstractHorse.getInventory();
        if (inv != null) {
            for (ItemStack item : inv.getContents()) {
                observedInventory.add((item == null) ? null : item.clone());
            }
        }
        setDirty();
    }

    // ------------------------------------------------------------------------
    /**
     * This method is called every tick when the horse is being ridden to do
     * various accounting tasks.
     *
     * This method should only be called when a Player is riding the horse, i.e.
     * in onPlayerMove().
     *
     * @param relativeTick a counter that increases by one every tick; the
     *        starting value is arbitrary.
     * @param horse the AbstractHorse entity.
     */
    public void onRidden(int relativeTick, AbstractHorse horse) {
        if (getLocation() != null && Util.isTrainable(horse)) {
            Location newLocation = horse.getLocation();
            double dist = Util.getHorizontalDistance(location, newLocation);
            Player rider = (Player) Util.getPassenger(horse);

            // Horses moving through water don't get dehydrated.
            if (!Util.isWaterlogged(newLocation.getBlock())) {
                // Suppress dehydration of max speed horses.
                if (getSpeedLevel() >= EasyRider.CONFIG.SPEED.getMaxLevel()) {
                    setHydration(1.0);
                } else {
                    setHydration(getHydration() - (dist / EasyRider.CONFIG.DEHYDRATION_DISTANCE));
                }

                if (isDehydrated()) {
                    // Extra debug information of dehydrated horses.
                    if (isDebug()) {
                        EasyRider.PLUGIN.debug(horse, " dehydrated (" + getHydration() + ") over dist " + dist);
                    }

                    PlayerState playerState = EasyRider.PLUGIN.getState(rider);

                    // Suppress dehydration messages once interval exceeds
                    // maximum.
                    if (!playerState.isNeglectful() &&
                        _messageRateLimiter.getCoolDownMillis() < MAX_MESSAGE_COOLDOWN_MILLIS &&
                        _messageRateLimiter.run(() -> {
                            rider.sendMessage(ChatColor.RED + getMessageName() +
                                              " is too dehydrated to benefit from training. Give it a drink of water.");
                            rider.playSound(rider.getLocation(), Sound.ENTITY_ITEM_BREAK, SoundCategory.NEUTRAL, 1.0f, 1.0f);
                        })) {
                        long newMessageCoolDown = Math.min(Math.max(MIN_MESSAGE_COOLDOWN_MILLIS,
                                                                    _messageRateLimiter.getCoolDownMillis() * 2),
                                                           MAX_MESSAGE_COOLDOWN_MILLIS);
                        _messageRateLimiter.setCoolDownMillis(newMessageCoolDown);
                    }
                } else {
                    _messageRateLimiter.setCoolDownMillis(MIN_MESSAGE_COOLDOWN_MILLIS);
                }
            }

            PlayerState playerState = EasyRider.PLUGIN.getState(rider);
            AttributeInstance horseAttribute = horse.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED);
            if (!EasyRider.CONFIG.VANILLA_STATS) {
                horseAttribute.setBaseValue(Math.min(playerState.getMaxSpeed(),
                                                 EasyRider.CONFIG.SPEED.getValue(getSpeedLevel())));
            }
        }
        setLastAccessed(System.currentTimeMillis());
    } // onRidden

    // ------------------------------------------------------------------------
    /**
     * When the horse has exceeded the maxium possible health, warn the player
     * that feeding it more gold will not increase its health (rate limited).
     *
     * @param player the player doing the feeding.
     * @param horse the horse entity.
     */
    public void onOverfed(Player player, AbstractHorse horse) {
        _overfedRateLimiter.run(() -> {
            player.sendMessage(ChatColor.RED + getMessageName()
                               + " has exceeded the maximum possible health. Feeding it more gold will not increase its health.");
            Location loc = horse.getLocation();
            loc.getWorld().playSound(loc, Sound.ENTITY_EXPERIENCE_ORB_PICKUP, SoundCategory.NEUTRAL, 1.0f, 1.0f);
        });
    }

    // ------------------------------------------------------------------------
    /**
     * Load this horse from the specified section of a YAML file.
     *
     * @param section the ConfigurationSection.
     */
    @SuppressWarnings("unchecked")
    public void load(ConfigurationSection section) {
        setUuid(UUID.fromString(section.getName()));
        ownerUuid = section.isSet("ownerUuid") ? UUID.fromString(section.getString("ownerUuid")) : null;
        setName(section.getString("name"));
        setDisplayName(section.getString("displayName"));
        setAppearance(section.getString("appearance"));
        setLocation((Location) section.get("location", null));
        setEquipment(section.getInt("equipment"));
        setDistanceTravelled(section.getDouble("distanceTravelled"));
        setDistanceJumped(section.getDouble("distanceJumped"));
        setNuggetsEaten(section.getInt("nuggetsEaten"));
        setSpeedLevel(section.getInt("speedLevel"));
        setJumpLevel(section.getInt("jumpLevel"));
        setHealthLevel(section.getInt("healthLevel"));
        setHydration(section.getDouble("hydration", 1.0));
        setLastAccessed(section.getLong("lastAccessed", System.currentTimeMillis()));
        setLastObserved(section.getLong("lastObserved", 0));
        setPublicHorse(section.getBoolean("public",false));

        // Default lastTamed to last access time (if owned). More useful than 0.
        lastTamed = section.getLong("lastTamed", getOwnerUuid() == null ? 0 : getLastAccessed());

        clearPermittedPlayers();
        for (String uuid : section.getStringList("permittedPlayers")) {
            try {
                OfflinePlayer player = Bukkit.getOfflinePlayer(UUID.fromString(uuid));
                if (player != null && player.getName() != null) {
                    permittedPlayers.add(player);
                } else {
                    EasyRider.PLUGIN.getLogger().warning("Horse " + getUuid().toString() + " could not load permitted player " + uuid);
                }
            } catch (IllegalArgumentException ex) {
                EasyRider.PLUGIN.getLogger().warning("Horse " + getUuid().toString() + " could not load permitted player " + uuid);
            }
        }

        observedInventory.clear();
        observedInventory.addAll((List<ItemStack>) section.getList("inventory", Collections.EMPTY_LIST));

        setClean();
    }

    // ------------------------------------------------------------------------
    /**
     * Save this horse to a YAML configuration.
     *
     * @param section the parent section that contains a section named after
     *        this horse's UUID. The latter contains the attributes of this
     *        horse.
     */
    public void save(ConfigurationSection parent) {
        ConfigurationSection section = parent.getConfigurationSection(getUuid().toString());
        if (section == null) {
            section = parent.createSection(getUuid().toString());
        }

        // Setting a value of null removes a key.
        section.set("ownerUuid", (getOwnerUuid() != null) ? getOwnerUuid().toString() : null);

        section.set("name", getName());
        section.set("displayName", getDisplayName());
        section.set("appearance", getAppearance());
        section.set("location", getLocation());
        section.set("equipment", getEquipment());
        section.set("distanceTravelled", getDistanceTravelled());
        section.set("distanceJumped", getDistanceJumped());
        section.set("nuggetsEaten", getNuggetsEaten());
        section.set("speedLevel", getSpeedLevel());
        section.set("jumpLevel", getJumpLevel());
        section.set("healthLevel", getHealthLevel());
        section.set("hydration", getHydration());
        section.set("lastAccessed", getLastAccessed());
        section.set("lastObserved", getLastObserved());
        section.set("lastTamed", getLastTamed());
	section.set("publicHorse", getPublicHorse());

        List<String> permittedUUIDs = permittedPlayers.stream().map(p -> p.getUniqueId().toString()).collect(Collectors.toList());
        section.set("permittedPlayers", permittedUUIDs);

        section.set("inventory", getObservedInventory());
        setClean();
    }

    // --------------------------------------------------------------------------
    /**
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((appearance == null) ? 0 : appearance.hashCode());
        result = prime * result + ((displayName == null) ? 0 : displayName.hashCode());
        long temp;
        temp = Double.doubleToLongBits(distanceJumped);
        result = prime * result + (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(distanceTravelled);
        result = prime * result + (int) (temp ^ (temp >>> 32));
        result = prime * result + equipment;
        result = prime * result + healthLevel;
        temp = Double.doubleToLongBits(hydration);
        result = prime * result + (int) (temp ^ (temp >>> 32));
        result = prime * result + jumpLevel;
        result = prime * result + (int) (lastAccessed ^ (lastAccessed >>> 32));
        result = prime * result + (int) (lastObserved ^ (lastObserved >>> 32));
        result = prime * result + (int) (lastTamed ^ (lastTamed >>> 32));
        result = prime * result + ((location == null) ? 0 : location.hashCode());
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + nuggetsEaten;
        result = prime * result + (outdatedAttributes ? 1231 : 1237);
        result = prime * result + ((ownerUuid == null) ? 0 : ownerUuid.hashCode());
        result = prime * result + speedLevel;
        result = prime * result + ((uuid == null) ? 0 : uuid.hashCode());
        return result;
    }

    // --------------------------------------------------------------------------
    /**
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof SavedHorse)) {
            return false;
        }
        SavedHorse other = (SavedHorse) obj;
        if (appearance == null) {
            if (other.appearance != null) {
                return false;
            }
        } else if (!appearance.equals(other.appearance)) {
            return false;
        }
        if (displayName == null) {
            if (other.displayName != null) {
                return false;
            }
        } else if (!displayName.equals(other.displayName)) {
            return false;
        }
        if (Double.doubleToLongBits(distanceJumped) != Double.doubleToLongBits(other.distanceJumped)) {
            return false;
        }
        if (Double.doubleToLongBits(distanceTravelled) != Double.doubleToLongBits(other.distanceTravelled)) {
            return false;
        }
        if (equipment != other.equipment) {
            return false;
        }
        if (healthLevel != other.healthLevel) {
            return false;
        }
        if (Double.doubleToLongBits(hydration) != Double.doubleToLongBits(other.hydration)) {
            return false;
        }
        if (jumpLevel != other.jumpLevel) {
            return false;
        }
        if (lastAccessed != other.lastAccessed) {
            return false;
        }
        if (lastObserved != other.lastObserved) {
            return false;
        }
        if (lastTamed != other.lastTamed) {
            return false;
        }
        if (location == null) {
            if (other.location != null) {
                return false;
            }
        } else if (!location.equals(other.location)) {
            return false;
        }
        if (name == null) {
            if (other.name != null) {
                return false;
            }
        } else if (!name.equals(other.name)) {
            return false;
        }
        if (nuggetsEaten != other.nuggetsEaten) {
            return false;
        }
        if (outdatedAttributes != other.outdatedAttributes) {
            return false;
        }
        if (ownerUuid == null) {
            if (other.ownerUuid != null) {
                return false;
            }
        } else if (!ownerUuid.equals(other.ownerUuid)) {
            return false;
        }
        if (speedLevel != other.speedLevel) {
            return false;
        }
        if (uuid == null) {
            if (other.uuid != null) {
                return false;
            }
        } else if (!uuid.equals(other.uuid)) {
            return false;
        }
        return true;
    }

    // ------------------------------------------------------------------------
    /**
     * Minimum dehydration message cooldown in milliseconds.
     */
    private static final long MIN_MESSAGE_COOLDOWN_MILLIS = 2 * 60 * 1000;

    /**
     * Maximum dehydration message cooldown in milliseconds. When the message
     * period exceeds this, messages are suppressed.
     */
    private static final long MAX_MESSAGE_COOLDOWN_MILLIS = 5 * 60 * 1000;

    /**
     * The unique ID of the horse, used as the primary key.
     */
    private UUID uuid;

    /**
     * The owning player's UUID, or null if not owned.
     */
    private UUID ownerUuid;

    /**
     * The name of the horse.
     *
     * Not currently used; reserved for future use.
     */
    private String name;

    /**
     * The display name (custom name) of the horse.
     */
    private String displayName;

    /**
     * The horse's appearance: colour, markings and variant.
     */
    private String appearance;

    /**
     * The last known location of the horse.
     */
    private Location location;

    /**
     * The equipment of the horse (saddle, armour) expressed as bit flags.
     */
    private int equipment;

    /**
     * The total distance travelled in metres.
     */
    private double distanceTravelled;

    /**
     * The total horizontal distance jumped in metres.
     */
    private double distanceJumped;

    /**
     * The total amount of gold consumed, converted to gold nuggets.
     */
    private int nuggetsEaten;

    /**
     * The 1-based level that determines the horse's speed, or 0 for
     * non-trainable AbstractHorses.
     */
    private int speedLevel;

    /**
     * The 1-based level that determines the horse's jump strength, or 0 for
     * non-trainable AbstractHorses.
     */
    private int jumpLevel;

    /**
     * The 1-based level that determines the horse's health, or 0 for
     * non-trainable AbstractHorses.
     */
    private int healthLevel;

    /**
     * Hydration level of the horse.
     */
    private double hydration;

    /**
     * Time stamp when the horse was last accessed, per
     * System.currentTimeMillis().
     */
    private long lastAccessed;

    /**
     * Boolean defining if the horse is for public use
     */
    private boolean publicHorse;

    /**
     * Time stamp when the horse was last observed in {@link #observe()}, per
     * System.currentTimeMillis().
     */
    private long lastObserved;

    /**
     * Time stamp when the horse was most recently tamed. 0 when there is no
     * owner.
     */
    private long lastTamed;

    /**
     * If true, the corresponding AbstractHorse entity needs all its attributes
     * updated to match current levels.
     *
     * This flag is set when swapping one horse with another using /horse-swap.
     * Usually in that case, one of the horses is not loaded in the world and
     * its attributes will be out of sync with the new levels applied to it.
     * This is reconciled later, on the first interaction.
     */
    private boolean outdatedAttributes;

    /**
     * The set of players permitted to access this horse.
     *
     * Elements are compared by UUID, as OfflinePlayer.getName() is null during
     * plugin initialisation, when {@link #load(ConfigurationSection)} is
     * called.
     */
    private final HashSet<OfflinePlayer> permittedPlayers = new HashSet<OfflinePlayer>();

    /**
     * Complete inventory contents (deep copy) when last observed.
     */
    private final ArrayList<ItemStack> observedInventory = new ArrayList<>();

    /**
     * True if this bean has never been in the database, i.e. it will result in
     * a database insert.
     */
    // @Transient
    private boolean _new;

    /**
     * True if this bean has unsaved changes.
     */
    // @Transient
    private boolean _dirty;

    /**
     * If true, this horse has been marked for debug logging.
     */
    private boolean _debug;

    /**
     * Limits the rate at which dehydration messages will be sent.
     */
    // @Transient
    private final RateLimiter _messageRateLimiter = new RateLimiter(0);

    /**
     * Limits the rate at which the player is warned about the horse being fed
     * past the maximum health level.
     */
    // @Transient
    private final RateLimiter _overfedRateLimiter = new RateLimiter(5000);

} // class SavedHorse
